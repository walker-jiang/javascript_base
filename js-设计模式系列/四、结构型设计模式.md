结构型设计模式关注对象或类之间的组合关系
## 套餐模式-外观模式
1、可以将兼容性判断逻辑或者其它复杂逻辑封装到一个函数里，这个函数就是外观
2、将复杂的子系统的调用通过封装简化调用
适用场景：这个可能用的很多但是这里把封装换了个名字，外观，为什么需要封装，有的是了为了提高易读性，大部分是由于提高易用性和可维护性，但多次使用时通过简单的外观函数就可以使用，修改时只需在外观函数内部修改即可
## 水管弯弯--适配器模式
当一个对象A的属性和方法需要在另一个对象B中使用，但是目前它的属性和方法并不是符合要求的，但是如果直接A的属性和方法可能在C对象中有没法使用它了，这时候可以引入一个适配器函数，将A的属性和方法适配成B所需要的，这时对C使用A一点影响也没有
1、参数适配器
```
function ParamAdapter(obj){
    var _adapter = {
        name: '雨夜清河'，
        title: '设计模式',
        age: 24,
        size: 100
    };
    for(var key in _adapter){
        _adapter[key] = obj[key] || _adapter[key]
    }
}
```
2、数据适配器
let tableColumn = [
    {
        key: 'name',
        title: '姓名'
    },
    {
        key: 'age',
        title: '年龄'
    }
];
function dataAdapter (data) {
    return data.map(function(item){
        let front = {};
        tableColumn.forEach(function(itemChild){
            front[itemChild.key] = item[[itemChild.key]]
        })
        return front
    })
}
$.ajax({
    url: '',
    success: function(response){
        if(response.result){
            dataAdapter(response.data);
        }
    }
})
## 代理模式
通过一个代理对象解决两个对象之间不能相互访问的问题
1、src代理，由于浏览器对ajax或者XHRHttp的同源策略限制，请求源于目标之间可能存在跨域，但是浏览器对src就没有这个限制，所以可以通过src做一些请求而且不同考虑同源限制
```
var Count = (function(){
  var img = new Image()
  return function(param){
    var str = 'http://www.count.com/a.gif?';
    for(var i in param) {
      str += i + '=' + param[i];
    }
    img.src = str;
  }
})
Count({num: 10});
2、保护代理
对主体对象的访问提供过滤作用
例子：可以通过保护代理做权限控制，将权限控制放在代理对象中
3、虚拟代理
将开销很大的对象延迟到真正需要的时候在执行，先执行代理对象
例子：图片预加载本地图片，等到图片出来了再加载真正的图片
适用场景：当需要适用的对象比较复杂或者需要很长事件去构造，这时可以用代理了

## 装饰者模式
目的：为了迎合频繁变化的需求，不改变原有功能
使用场景：当项目经理告诉你用户说这个功能挺不错的但是希望你还能。。。。
使用方法：新建装饰者对象，在装饰者对象中将原有功能和新功能一起调用，这样就是了
例子：
```
document.getElementById('input).onclick = function () {
  console.log('提示用户输入格式')
}
// 现在有新增需求，用户点击前有个默认提示，用户点击后默认提示隐藏显示输入格式提示
document.getElementById('input).onclick = function () {
  console.log('默认提示消失')
  console.log('提示用户输入格式显示')
}
**注** 很明显这样在原来的函数上修改不满足开闭原则
// 装饰者函数
var decorate = function (newFn) {
  var oldFn = document.getElementById('input).onclick
  document.getElementById('input).onclick = function () {
    oldFn()
    newFn()
  }
}
// 优化一下
`
  var decorate = function (newFn) {
    var input = document.getElementById('input')
    var oldFn = input.onclick
    if (oldFn instanceof Function) {
      input.onclick = function () {
        oldFn()
        newFn()
      }
    } else {
      input.onclick = newFn
    }
  }
`
## 桥接模式
含义：系统能沿着多个维度变化但是不增加其复杂度并且是解耦的
使用场景：多个复杂对象存在相似部分可以抽象出很多部件单元，然后在复杂对象使用时对部件单元进行桥接
使用方法：对每个复杂对象的逻辑中的相似部分拆分，通过参数传递得到自己想要的部件，使用时把需要的部件进行桥接
例如
`
var Cat = function () {
  go: (){
    console.log('一步20cm')
  },
  jumo: () {
    console.log('一跃2m高')
  }
}
var Person = function () {
  go: (){
    console.log('一步50cm')
  },
  jumo: () {
    console.log('一跃1m高')
  }
}
// 抽象
var go = function (height) {
  console.log('一步' + height)
}
var jump = function(distance){
  console.log('一跃'+distance+'高')
}
var Person = function () {
  go: go('50'),
  jumo: jumo('1m')
}
...
`
优点：可以沿着多个维度变化，比如Person内部可以增加其它动作但是对Cat时没有影响的
## 组合模式
