结构型设计模式关注对象或类之间的组合关系
## 套餐模式-外观模式
1、可以将兼容性判断逻辑封装到一个函数里，这个函数就是外观
2、将复杂的子系统的调用通过封装简化调用
```
function addEvent(dom, type, fn){
    if(dom.addEventListener){
        dom.addEventListener(type, fn, false);
    } else if(dom.attachEvent){
        dom.attachEvent('on'+type,fn);
    }else {
        dom['on'+type] = fn;
    }
}
addEvent(document.getElementById('myinput'), click, function(){});
```
```
var A = {
    g: function(id){
        return document.getElementById(id),
    },
    css: function(id, key, value){
        document.getElement(id).style[key] = value;
    }
};
A.g('app');
A.css('app', 'className', 'app_header');
```
适用场景：需要简化调用的时候可以用
## 水管弯弯--适配器模式
1、参数适配器
```
function ParamAdapter(obj){
    var _adapter = {
        name: '雨夜清河'，
        title: '设计模式',
        age: 24,
        size: 100
    };
    for(var key in _adapter){
        _adapter[key] = obj[key] || _adapter[key]
    }
}
```
2、数据适配器
let tableColumn = [
    {
        key: 'name',
        title: '姓名'
    },
    {
        key: 'age',
        title: '年龄'
    }
];
function dataAdapter (data) {
    return data.map(function(item){
        let front = {};
        tableColumn.forEach(function(itemChild){
            front[itemChild.key] = item[[itemChild.key]]
        })
        return front
    })
}
$.ajax({
    url: '',
    success: function(response){
        if(response.result){
            dataAdapter(response.data);
        }
    }
})
## 代理模式
通过一个代理对象解决两个对象之间不能相互访问的问题
1、src代理，由于浏览器对ajax或者XHRHttp的同源策略限制，请求源于目标之间可能存在跨域，但是浏览器对src就没有这个限制，所以可以通过src做一些请求而且不同考虑同源限制
```
var Count = (function(){
  var img = new Image()
  return function(param){
    var str = 'http://www.count.com/a.gif?';
    for(var i in param) {
      str += i + '=' + param[i];
    }
    img.src = str;
  }
})
Count({num: 10});
2、保护代理
对主体对象的访问提供过滤作用
例子：可以通过保护代理做权限控制，将权限控制放在代理对象中
3、虚拟代理
将开销很大的对象延迟到真正需要的时候在执行，先执行代理对象
例子：图片预加载本地图片，等到图片出来了再加载真正的图片
适用场景：当需要适用的对象比较复杂或者需要很长事件去构造，这时可以用代理了