## 简单工厂模式
这里的工厂式用来生产对象的
目的：简单工厂模式让对象的使用者不用关心对象的创建细节，只需要传递一个参数就可以了
适用场景：所需的类最好是相似的，可以这样理解，工厂生产相似的产品才能节约成本，因为相同的部分可以用一个设备去生产，相似的才能抽取出相同的部分，对不同的部分根据参数进行不同的逻辑判断，如果没有相似的部分那么使用的意义这是简化了最后创建的那一步

例如要完成一个普通的登录模块的功能，需求是
- 用户名内容不符合规范提示弹框‘用户名不能多余16个字母或者数字’
```
var LoginAlert = function(text){
  this.content = text;
}
Login.prototype.show = {}; // 显示

var userNameAlert = new LoginAlert('用户名不能多于16个数字或字母');
LoginAlert.show();
```
- 用户密码输入错误时提示弹框‘输入的密码不正确’
```
var LoginAlert = function(text){
  this.content = text;
}
Login.prototype.show = {}; // 显示
if(){ // 用户名不规范
  var userNameAlert = new LoginAlert('用户名不能多于16个数字或字母');
  LoginAlert.show();
}else if(){ // 密码不规范
  var passwordAlert = new LoginAlert('密码不正确');
  LoginAlert.show();
}
```
- 进行到这里这么写没问题，原型属性show属于静态公有的提高了性能，LoginAlert函数得到了复用。接下来，要在用户名不存在时提示'用户名不存在，请重新输入'并且添加一个注册按钮，此时代码没法复用了只能重新写一种时之前的代码重构，一种时新建类适应新功能，先看看新建类如何写
```
var LoginConfirm = function(text){
  this.content = text;
  this.buttonTxt = '注册';
};
LoginConfirm.prototype.show = function(){};

if(){ // 用户不存在
  var loginFailConfirm = new LoginConfirm('用户名不存在，请重新输入');
  LoginConfirm.show();
}
```
- 登录成功的用户给提示弹框'欢迎回来，请的输入您今天的心情吧'，原来的又没法复用了，继续新建类
```
var LoginPrompt = function(){
  this.content = text;
  this.button1Txt = '确定';
  this.button1Txt = '取消';
};
LoginPrompt.prototype.show = function(){};

if(){ // 登录成功
  var loginSuccessConfirm = new LoginPrompt();
  LoginPrompt.show();
}
```
+ 最终的完整代码
```
var LoginAlert = function(text){
  this.content = text;
}
Login.prototype.show = {}; // 显示

var LoginConfirm = function(text){
  this.content = text;
  this.buttonTxt = '注册';
};
LoginConfirm.prototype.show = function(){};

var LoginPrompt = function(){
  this.content = text;
  this.button1Txt = '确定';
  this.button1Txt = '取消';
};
LoginPrompt.prototype.show = function(){};

if(){ // 用户名多余16个数字或字母
  var userNameAlert = new LoginAlert('用户名不能多于16个数字或字母');
  LoginAlert.show();
}else if(){ // 密码不规范
  var passwordAlert = new LoginAlert('密码不正确');
  LoginAlert.show();
}else if(){ // 用户不存在
  var loginFailConfirm = new LoginConfirm('用户名不存在，请重新输入');
  LoginConfirm.show();
}else if(){ // 登录成功
  var loginSuccessConfirm = new LoginPrompt();
  LoginPrompt.show();
}
```
以上都是通过新建类来满足新需求，之前的代码得不到复用，那么用重构该如何做呢，我们发现这些类有很多共同点，那么创建的过程能不能交给一个工厂呢？
```
// type: 弹框类型 text: 需要提示的文本
var LoginAlertFactory = function(type, text){
  this.content = text;
  switch(type){
    case: ...
  };
};
LoginAlertFactory.prototype.show = function(){};
```
- 上面的方案时自己通过工厂模式对代码进行了重构、复用，那么如果有个写注册功能的小伙伴想复用你的方法怎么办呢？你不知道它是否知道new实例化或者各个函数需要怎样的入参，解决方案同样是工厂模式，根据它传的参数来返回不同的实例，具体怎么创建的，你让它省省心吧。
## 工厂方法模式
在看了我们最终的代码后我们发现重构之后简单工厂模式的实现了对创建对象过程的隐藏，但是对于万变的需求来说，每每在工厂加功能需要同时写功能函数和修改工厂里的逻辑代码，而根据依赖倒转原则尽可能的是针对接口编程而不是实现编程，但js中没有接口，我们可以用对象的原型来模拟接口
```
var Factory = function(type){
  // 有时候别人使用可能忘记了new 安全起见加个有无的逻辑判断
  if(this instanceof Factory){
    return (new this[type]())
  }else{
    return new Factory()
  }
} 
Factory.prototype = {
  A: function(){}
};
//Factory 满足开闭原则，对扩展开放对修改关闭
```
## 抽象工厂模式
概念：通过对类的工厂抽象使其业务用于对产品类簇的创建而不是某一类产品的实例
```
// VehicleFactory 抽象工厂对象内部逻辑的作用是 判断有没有该子工厂 有的话
      var VehicleFactory = function(subType, superType){
        if(typeof VehicleFactory[superType] === 'function'){ // 抽象类判断
          function F(){};
          F.prototype = new VehicleFactory[superType]();
          subType.constructor = subType
          subType.prototype = new F();
        }else{
          throw new Error('未创建该抽象类');
        }
      };
      VehicleFactory.Car = function(){
        this.type = 'car';
      };
      VehicleFactory.Car.prototype = {
        getPrice: function(){
          return new Error('抽象方法不能调用');
        },
        getSpeed: function(){
          return new Error('抽象方法不能调用');
        }
      };

      var BMW = function(price, speed){ // 抽象的产品类
        this.price = price;
        this.speed = speed;
        this.getPrice = function(){
          return this.speed;
        };
      };
      VehicleFactory(BMW, 'Car'); // 创建对应抽象工厂

      var smallBWM = new BMW(1,2);
      console.log(smallBWM.getPrice());
```
## 建造者模式
将一个复杂的构建与其表示相分离，使得同样的构建过程可以创建不同的表示即分步骤构建一个复杂的对象，分步骤是个稳定的算法，复杂对象的各个部分经常变化

适用场景：要建造的对象由很多复杂的对象构成，这样把对象的构建过程独立出来，对于以后新对象的修改满足开闭原则
```
var Contributor = function(name, constract, hobbys, skills, jobs){
  this.name = name; // 姓名 需要部分隐藏
  this.constract = constract; // 联系方法 需要部分隐藏
  this.hobbys = hobbys // 兴趣
  this.skills = skills // 特长
  this.jobs = jobs; // 可以分类
  。。。
};
```
上面这个对象可能会很大，对象姓名和联系方式之间有共同点可以抽象到一个对象，但是各个小对象可能会很多，如果用建造者模式重构一下
``` 
//  应聘者对象、
var Human = function(param){
  // 技能
  this.skill = param && param.skill || '保密'
  // 兴趣爱好
  this.hobby = param && param.skill || '保密'
}
Human.prototype = {
  getSkill: function () {
    return this.skill
  },
  getHobby: function(){
    return this.hobby
  }
};
// 基本信息对象
var BasicInfo = function(){
  ...
};
// 工作对象
vat Work = function(work){
  switch(work){
    '前端': 
      this.work = '开发';
      this.des = '累啊累'; 
      break;
    ...
  }
};
Word.prototype.changeWork = function(work){
  this.work = work;
};
Word.prototype.changeWorkDec = function(des){
  this.des = des;
};
// A具体建造者对象
var Person = function(basicInfo, work...){
  var _person = new Human();
  _person.basicInfo = new BasicInfo(basicInfo);
  ...
  return _person
};
```
优点：构建过程清晰、容易更换建造者
```
## 原型模式
例子：实现页面中轮播图，且切换方式不确定，图片数量也不确定
```
// 共同点抽象出来作为基类
var LoopImages = function(imgArr, container){
  this.imageArray = imgArr; // 轮播图片数组
  this.container = container; // 轮播图片容器
  this.createImage = function(){}; // 创建轮播图片
  this.changeImage = function(){} // 切换下一张图片
}
// 为了满足轮播的多种切换方式，通过继承基类重写切换方式实现
var SlideLoopImg = function(imgArr, container){
  LoopImages.call(this, imgArr, container); // 构造函数继承
  this.changeImgage = function(){ // 重写切换方式
  };
};
。。。
```
分析：这是一种比较常规的做法，表面上实现了公用但不是真正的共享，每一种切换方式都需要调用基类构造函数，那么如何做到真正的共享呢
概念：原型模式就是将可复用、可共享的、耗时大的逻辑从基类中提取然后放入基类原型，然后子类通过组合继承或者寄生组合式继承实现共享
```
var LoopImages = function(imgArr, container){
  this.imageArray = imgArr; // 轮播图片数组
  this.container = container; // 轮播图片容器
}
LoopImages.prototype.createImage = function(){}; // 创建轮播图片
LoopImages.prototype.changeImage = function(){} // 切换下一张图片

var SlideLoopImg = function(imgArr, container){
  LoopImages.call(this, imgArr, container); // 构造函数继承
};
SlideLoopImg.prototype = new LoopImages();
SlideLoopImg.prototype.changeImgage = function(){ // 重写切换方式
。。。
};
```
使用场景：从上面可以看出原型模式的比普通的创建的好处在于将可复用的、耗时的的逻辑放在构造函数的原型里，这样不仅省去了创建的步骤而且原型对象在内存中还被共享也就是省内存，这样就能创建很多相同或者相似的对象
## 单例模式
单例模式的作用
1、提供一个命名空间
```
var Ming = {
  g: function(){}
  ...
};
var Hong = Ming;
```
这里Ming就是一个单例对象Hong和Ming一样都是引用
2、模块划分
```
var HR = {
  Util: {},
  Tool: {}
  ...
};
```
模块划分的基础是有一个命名空间
当然单例模式还可以用来创建静态私有变量
```
var Conf = (function(){
  var conf = {
    Max_NUM: 100
  };
  return {
    get: function(name){
      return conf[name] ? conf[name] : null
    }
  };
})()
```
惰性创建
```
var LazyCreate = function(){
  var a = 1;
  var instance = null;
  function Single(){

  };
  return function(){
    if(!instance){
      instance = new Single(); 
    }
    return instance;
  }
}()
LazyCreate(); // 单例模式
```
