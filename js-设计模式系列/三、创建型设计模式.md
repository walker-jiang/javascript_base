## 工厂方法模式
定义：通过对产品类的抽象使其创建业务主要用于创建多类实例
即：再构造函数中创建指定类型的实例，原型属性方法中定义创建过程
算法骨架：
`
var Factory = function(type, content) {
  if (this instanceof Factory) {
    return this[type](cotent)
  } else {
    return (new Factory([type](content)))
  }
}
Factory.prototype.type1 = function(content) {

}
使用场景：需要创建大量对象，对象间可以分类合并（相似度高）
```
## 建造者模式
定义：将一个复杂对象的构建与表示分离，同样的构建过程可以创建不同的表示。  
即：把存在变化的部分从大对象里抽出来，在构建过程中传入参数控制变化。
算法骨架：
`
var Builder = function(arg1, args2...) {
  var entity = {};
  entity.part1 = new Part1(arg1);
  entity.part2 = new Part2(args2);
  return entity
}
var Part1 = function(arg1) {
  switch (arg1) {
    case ...
  }
}

`
使用场景：一个对象的某一部分易变就可通过建造者模式抽象出来，这样单独维护易变部分。

```
## 原型模式
例子：实现页面中轮播图，且切换方式不确定，图片数量也不确定
```
// 共同点抽象出来作为基类
var LoopImages = function(imgArr, container){
  this.imageArray = imgArr; // 轮播图片数组
  this.container = container; // 轮播图片容器
  this.createImage = function(){}; // 创建轮播图片
  this.changeImage = function(){} // 切换下一张图片
}
// 为了满足轮播的多种切换方式，通过继承基类重写切换方式实现
var SlideLoopImg = function(imgArr, container){
  LoopImages.call(this, imgArr, container); // 构造函数继承
  this.changeImgage = function(){ // 重写切换方式
  };
};
。。。
```
分析：这是一种比较常规的做法，表面上实现了公用但不是真正的共享，每一种切换方式都需要调用基类构造函数，那么如何做到真正的共享呢
概念：原型模式就是将可复用、可共享的、耗时大的逻辑从基类中提取然后放入基类原型，然后子类通过组合继承或者寄生组合式继承实现共享
```
var LoopImages = function(imgArr, container){
  this.imageArray = imgArr; // 轮播图片数组
  this.container = container; // 轮播图片容器
}
LoopImages.prototype.createImage = function(){}; // 创建轮播图片
LoopImages.prototype.changeImage = function(){} // 切换下一张图片

var SlideLoopImg = function(imgArr, container){
  LoopImages.call(this, imgArr, container); // 构造函数继承
};
SlideLoopImg.prototype = new LoopImages();
SlideLoopImg.prototype.changeImgage = function(){ // 重写切换方式
。。。
};
```
使用场景：首先时一个对象需要被多次创建（创建一次的化原型模式没有优越感），然后就是每次创建的对象有差异（没有差异的话用单例模式多好），从上面可以看出原型模式的比普通的创建的好处在于将可复用的、耗时的的逻辑放在构造函数的原型里，而将简单差异化的放在构造函数里，这样不仅省去了创建的步骤而且原型对象在内存中还被共享也就是省内存，这样就能创建很多相同或者相似的对象
## 单例模式
js中创建单例比较简单，所以更多的时说单例模式的作用
1、提供一个命名空间并且此时也相应的有了私有变量
```
var Ming = {
  g: function(){}
  ...
};
var Hong = Ming;
```
这里Ming就是一个单例对象Hong和Ming一样都是引用
当然单例模式还可以用来创建静态私有变量
```
var Conf = (function(){
  var conf = {
    Max_NUM: 100
  };
  return {
    get: function(name){ // 只能读
      return conf[name] ? conf[name] : null
    },
    set: function(name, value) { // 只能初始化
      if (conf[name]) {
        return conf[name]
      } else {
        conf[name] = value
      }
    }
  };
})()
```
