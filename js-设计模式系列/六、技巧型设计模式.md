## 链模式
定义：通过在对象方法中将对象返回，实现对一个对象多个方法的链式调用，从而简化该对象的多个方法的多次调用时，对该对象的多次引用
即：将当前对象作为返回值从而能链式的多次调用
算法骨架
`
var Link = function () {
  this.run = function(){
    return this
  }
  this.walk = function(){
    return this
  }
  ...
}
(new Link()).run().walk()
`
适用场景：对象内的接口可能会多次调用时，链模式能简化调用方法
## 委托模式
定义：多个对象接收并处理同一请求，他们将请求委托给另一个对象统一处理
即：把请求交给一个对象，然后这个对象再分配给对应的对象
算法骨架
`
// 这里更多的是一种思维，例如：多个元素都需要绑定统一事件，这样就过多的消耗了内存，利用事件冒泡原理可以在父元素/// 绑定事件，然后通过事件源判断然后是那个子元素，或者一个页面触发多个请求，可以将请求合并在一起，然后在前端进行/// 数据分发
`
适用场景：请求多，可合并
优点：集中处理，减少消耗
## 节流模式
定义：对重复的业务逻辑进行节流控制，执行最后一次操作并取消其它操作，一提高性能
即：取消没必要的调用
算法骨架
`
var throttle = function (){
  var isClear = arguments[0], fn
  var params = {
    time: 300,
    args: [],
    context: null
  }
  if (typeof isClear === 'boolean') {
    fn = arguments[1]
    fn.ID && clearTimeout(fn.ID)
  } else {
    fn = isClear
    params = {
      context: null,
      time: 300,
      args: []
    }
    arguments.callee(true, fn)
    fn.ID = setTimeout(function() {
      fn.apply(params.context, params.args)
      }, params.time)
  }
}
// 一方面能实现是由于延迟执行的setTimeout，一方面有赖于fn的静态变量ID，每次调用函数时都会判断之前的ID有没有，如果有就清除
`
适用场景：会频繁触发但是只需最后一个操作的结果的时候，例如输入时提示，滚动后返回顶部按钮的出现
优点：使用节流器后能取消不少没必要的逻辑，很能提升性能
